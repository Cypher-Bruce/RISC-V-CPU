\documentclass[a4paper,12pt]{article} 
\usepackage[top = 2.5cm, bottom = 2.5cm, left = 2.5cm, right = 2.5cm]{geometry} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx} 
\usepackage{setspace}
\setlength{\parindent}{0in}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{multicol}
\usepackage{datetime}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[style=numeric,sorting=none]{biblatex}
\addbibresource{reference.bib}
\usepackage{minted}

\title{\textbf{Computer Organization (H) Project Report}}
\author{Mengxuan Wu \and Taojie Wang \and Sirui Wu}
\newdate{date}{31}{05}{2024}
\date{\displaydate{date}}

\begin{document}

\maketitle

\section{Developer Contribution}

\begin{table}[H]
    \centering
    \begin{tabular}{cccc}
        \toprule
        Name & Student ID & Contribution & Percentage \\
        \midrule
        Mengxuan Wu & 12212006 & Pipeline Design and Hazard Handling & 33.3\% \\
        Taojie Wang & 12210519 & Pipeline Design and Testing  & 33.3\% \\
        Sirui Wu & 12210122 &  RISC-V 32 Assembly Code Writing& 33.3\%\\
        \bottomrule
    \end{tabular}
\end{table}

\section{CPU Design}

\subsection{CPU Feature}

\begin{itemize}
    \item ISA: RISC-V 32 Basic Instruction Set, Support 32 32-bit registers, No exception handling
    \item CPU Clock: 5-stage Pipeline, 23MHz, Handle hazard by forwarding and stalling
    \item Storage: Harvard architecture, 64KB each for instruction and data memory
    \item IO Design: MMIO, IO device address begins at \texttt{0xFFC0}
\end{itemize}

\subsection{CPU Ports}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{figure/CPU.png}
    \caption{CPU}
    \label{fig:CPU}
\end{figure}

\subsubsection{Input}

\begin{table}[H]
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            Related Module & Port Name & Port Width & Description \\
            \midrule
            Clock & clk & 1 & Clock signal generated by IP core \\
            \midrule
            Reset & rst & 1 & Reset signal (high-enable) \\
            \midrule
            \multirow{4}{*}{IO Device Input} & debounced\_button & 5 & Debounced button signal \\
            & push\_button\_flag & 5 & Flag indicating a button push down event \\ 
            & release\_button\_flag & 5 & Flag indicating a button release event \\ 
            & switch & 24 & Switch signal \\
            \midrule
            \multirow{5}{*}{Uart Signal} & kick\_off\_flag & 1 & Flag indicating communication mode or working mode \\
            & uart\_clk & 1 & Clock for UART module(23MHz) \\
            & upg\_adr & 15 &  Address to write in memory used by UART mode\\
            & upd\_dat & 32 & Data to write into memory by UART mode\\
            & upg\_wen & 1 & Write enable in UART mode\\
            \bottomrule
        \end{tabular}
    }
\end{table}

\subsubsection{Output}

\begin{table}[H]
    \centering
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            Related Module & Port Name & Width & Explanation \\
            \midrule
            Led Output & led & 24 & LED output signal for displaying status or information \\
            \midrule
            \multirow{7}{*}{Seven Segment Tube Display Output} & seven\_seg\_tube & 32 & Output signal for the seven segment tube display \\
            & advanced\_mode\_flag & 1 & Flag indicating whether advanced mode is activated \\ 
            & adv\_seven\_seg\_tube\_left & 32 & Output signal for the left part of the advanced seven segment tube display \\
            & adv\_seven\_seg\_tube\_right & 32 & Output signal for the right part of the advanced seven segment tube display \\
            & dot\_flag & 8 & Flag indicating which dots should be illuminated on the display \\
            & minus\_sign\_flag & 8 & Flag indicating whether a minus sign should be displayed \\
            & show\_none\_flag & 8 & Flag indicating whether the display should be turned off \\
            \bottomrule
        \end{tabular}
    }
\end{table}


\subsection{CPU Structure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figure/CPU Elaborated Design.png}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figure/CPU Design.png}
\end{figure}

\subsubsection{Top}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        raw\_clk & input & 1 & Raw clock signal \\
        raw\_rst & input & 1 & Raw reset signal \\
        switch & input & 24 & Switch inputs \\
        button & input & 5 & Button inputs \\
        led & output& 24 & LED outputs \\
        tube\_select\_onehot & output & 8 & One-hot selection for tube display \\
        tube\_shape & output & 8 & Shape data for tube display \\
        rx & input & 1 & UART receive signal \\
        tx & output & 1 & UART transmit signal \\
        \bottomrule
    \end{tabular}
\end{center}


\paragraph{Description}
The \texttt{Top} module integrates various sub-modules to form the complete system. It includes the main clock, debouncer, UART, CPU, and seven-segment tube driver modules.

\subsubsection{CPU\_Main\_Clock\_ip}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        clk\_in1  & input  & 1 & Raw clock input \\
        clk\_out1 & output & 1 & CPU clock output (23MHz) \\
        clk\_out2 & output & 1 & UART clock output (10MHz) \\
        \bottomrule
    \end{tabular}
\end{center}


\paragraph{Description}
The \texttt{CPU\_Main\_Clock\_ip} module generates two clock signals from the raw clock input: a 23MHz clock for the CPU and a 10MHz clock for the UART.

\subsubsection{Debouncer}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        raw\_clk                & input  & 1 & Raw clock signal \\
        rst                     & input  & 1 & Reset signal \\
        button                  & input  & 5 & Button inputs \\
        debounced\_button       & output & 5 & Debounced button signals \\
        push\_button\_flag      & output & 5 & Push button flag signals \\
        release\_button\_flag   & output & 5 & Release button flag signals \\
        \bottomrule
    \end{tabular}
\end{center}


\paragraph{Description}
The \texttt{Debouncer} module debounces the raw button inputs, providing stable button signals and flagging push and release events.

\subsubsection{UART}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            uart\_clk\_in       & input  & 1  & UART clock input (10MHz) \\
            raw\_clk            & input  & 1  & Raw clock signal \\
            raw\_rst            & input  & 1  & Raw reset signal \\
            start\_pg           & input  & 1  & Start program signal from push button \\
            kick\_off\_flag     & output & 1  & Mode flag (1: working, 0: communication) \\
            uart\_clk\_out      & output & 1  & UART clock output \\
            upg\_wen            & output & 1  & UART write enable \\
            upg\_adr            & output & 15 & UART address output \\
            upg\_dat            & output & 32 & UART data output \\
            rst                 & output & 1  & Reset signal \\
            rx                  & input  & 1  & UART receive signal \\
            tx                  & output & 1  & UART transmit signal \\
            \bottomrule
        \end{tabular}
    }
\end{center}


\paragraph{Description}
The \texttt{UART} module handles UART communication, providing interface signals for data transmission and reception, and managing write operations to memory.

\subsubsection{CPU\_Top}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk                             & input  & 1  & CPU clock signal \\
            rst                             & input  & 1  & Reset signal \\
            switch                          & input  & 24 & Switch inputs \\
            debounced\_button               & input  & 5  & Debounced button inputs \\
            push\_button\_flag              & input  & 5  & Push button flag signals \\
            release\_button\_flag           & input  & 5  & Release button flag signals \\
            led                             & output & 24 & LED outputs \\
            seven\_seg\_tube                & output & 32 & Seven-segment tube data \\
            minus\_sign\_flag               & output & 8  & Minus sign flag for tube display \\
            dot\_flag                       & output & 8  & Dot flag for tube display \\
            show\_none\_flag                & output & 8  & Show none flag for tube display \\
            advanced\_mode\_flag            & output & 1  & Advanced mode flag \\
            adv\_seven\_seg\_tube\_left     & output & 32 & Advanced mode left tube data \\
            adv\_seven\_seg\_tube\_right    & output & 32 & Advanced mode right tube data \\
            kick\_off\_flag                 & input  & 1  & Mode flag (1: working, 0: communication) \\
            uart\_clk                       & input  & 1  & UART clock signal \\
            upg\_wen                        & input  & 1  & UART write enable \\
            upg\_adr                        & input  & 15 & UART address input \\
            upg\_dat                        & input  & 32 & UART data input \\
        \bottomrule
    \end{tabular}
}
\end{center}


\paragraph{Description}
The \texttt{CPU\_Top} module is the main CPU module, interfacing with various inputs and outputs, including switches, debounced buttons, LEDs, and seven-segment tube displays. It also manages UART communication signals.

\subsubsection{Seven\_Seg\_Tube\_Driver}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            raw\_clk                        & input  & 1  & Raw clock signal \\
            rst                             & input  & 1  & Reset signal \\
            data                            & input  & 32 & Data for seven-segment tube display \\
            minus\_sign\_flag               & input  & 8  & Minus sign flag \\
            dot\_flag                       & input  & 8  & Dot flag \\
            show\_none\_flag                & input  & 8  & Show none flag \\
            advanced\_mode\_flag            & input  & 1  & Advanced mode flag \\
            adv\_seven\_seg\_tube\_left     & input  & 32 & Advanced mode left tube data \\
            adv\_seven\_seg\_tube\_right    & input  & 32 & Advanced mode right tube data \\
            tube\_select\_onehot            & output & 8  & One-hot selection for tube display \\
            tube\_shape                     & output & 8  & Shape data for tube display \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Seven\_Seg\_Tube\_Driver} module drives the seven-segment tube display, handling various display flags and data inputs to control the tube selection and shape output.

\subsubsection{Instruction\_Fetch}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk & input & 1 & Clock signal \\
            rst & input & 1 & Reset signal \\
            wrong\_prediction\_flag & input & 1 & Wrong branch prediction flag \\
            branch\_pc & input & 32 & Branch target address \\
            stall\_flag & input & 1 & Stall signal \\
            program\_counter\_prediction & output & 32 & Predicted program counter \\
            program\_counter & output & 32 & Current program counter \\
            prev\_pc & output & 32 & Previous program counter \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Instruction\_Fetch} module is responsible for fetching instructions from the instruction memory. It handles the program counter logic, including branch prediction and stall conditions.

\subsubsection{Instruction\_Memory}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        clk                 & input  & 1  & Clock signal \\
        program\_counter    & input  & 32 & Address of the current instruction \\
        inst                & output & 32 & Instruction data \\
        kick\_off\_flag     & input  & 1  & UART kick-off flag \\
        uart\_clk           & input  & 1  & UART clock signal \\
        upg\_wen            & input  & 1  & UART write enable \\
        upg\_adr            & input  & 14 & UART write address \\
        upg\_dat            & input  & 32 & UART write data \\
        \bottomrule
    \end{tabular}
\end{center}

\paragraph{Description}
The \texttt{Instruction\_Memory} module fetches the instruction data from the instruction memory based on the program counter. It also supports UART-based updates for loading new instructions.

\subsubsection{Program\_Counter\_Prediction}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk                             & input  & 1  & Clock signal \\
            rst                             & input  & 1  & Reset signal \\
            branch\_from\_pc                & input  & 32 & Branch origin address \\
            branch\_to\_pc                  & input  & 32 & Branch target address \\
            program\_counter                & input  & 32 & Current program counter \\
            branch\_flag                    & input  & 1  & Branch flag \\
            program\_counter\_prediction    & output & 32 & Predicted program counter \\
            prev\_pcp                       & output & 32 & Previous program counter prediction \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Program\_Counter\_Prediction} module predicts the next program counter value based on branch instructions. It updates the program counter prediction for the instruction fetch stage.

\subsubsection{Controller}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        inst                & input  & 32 & Instruction data \\
        branch\_flag        & output & 1  & Branch flag \\
        ALU\_operation      & output & 2  & ALU operation code \\
        ALU\_src\_flag      & output & 1  & ALU source flag \\
        mem\_read\_flag     & output & 1  & Memory read flag \\
        mem\_write\_flag    & output & 1  & Memory write flag \\
        mem\_to\_reg\_flag  & output & 1  & Memory to register flag \\
        reg\_write\_flag    & output & 1  & Register write flag \\
        jal\_flag           & output & 1  & JAL instruction flag \\
        jalr\_flag          & output & 1  & JALR instruction flag \\
        lui\_flag           & output & 1  & LUI instruction flag \\
        auipc\_flag         & output & 1  & AUIPC instruction flag \\
        \bottomrule
    \end{tabular}
\end{center}

\paragraph{Description}
The \texttt{Controller} module decodes the instruction and generates control signals for the ALU, memory access, and register write operations. It also handles specific instruction flags for branching and immediate operations.

\subsubsection{Immediate\_Generator}

\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        inst & input  & 32 & Instruction data \\
        imme & output & 32 & Immediate value \\
        \bottomrule
    \end{tabular}
\end{center}

\paragraph{Description}
The \texttt{Immediate\_Generator} module extracts the immediate value from the instruction, which is used for ALU operations and memory addressing.

\subsubsection{Decoder}
\begin{center}
    \begin{tabular}{cccc}
        \toprule
        \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
        \midrule
        inst                & input  & 32 & Instruction data \\
        read\_reg\_idx\_1   & output & 5  & Read register index 1 \\
        read\_reg\_idx\_2   & output & 5  & Read register index 2 \\
        write\_reg\_idx     & output & 5  & Write register index \\
        \bottomrule
    \end{tabular}
\end{center}

\paragraph{Description}
The \texttt{Decoder} module decodes the instruction to determine the source and destination register indices for the register file operations.

\subsubsection{Register}
\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk                 & input  & 1  & Clock signal \\
            rst                 & input  & 1  & Reset signal \\
            reg\_write\_flag    & input  & 1  & Register write flag \\
            read\_reg\_idx\_1   & input  & 5  & Read register index 1 \\
            read\_reg\_idx\_2   & input  & 5  & Read register index 2 \\
            write\_reg\_idx     & input  & 5  & Write register index \\
            write\_data         & input  & 32 & Data to be written to the register \\
            read\_data\_1       & output & 32 & Data read from register 1 \\
            read\_data\_2       & output & 32 & Data read from register 2 \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Register} module implements the register file, providing read and write access to the CPU registers based on the control signals and register indices.

\subsubsection{Forwarding\_Mux}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            read\_data\_1\_raw              & input  & 32 & Raw data read from register 1 \\
            read\_data\_2\_raw              & input  & 32 & Raw data read from register 2 \\
            read\_data\_1\_forwarding       & input  & 32 & Forwarded data for register 1 \\
            read\_data\_2\_forwarding       & input  & 32 & Forwarded data for register 2 \\
            read\_data\_1\_forwarding\_flag & input  & 1  & Forwarding flag for register 1 \\
            read\_data\_2\_forwarding\_flag & input  & 1  & Forwarding flag for register 2 \\
            read\_data\_1                   & output & 32 & Data for ALU input 1 \\
            read\_data\_2                   & output & 32 & Data for ALU input 2 \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Forwarding\_Mux} module selects the appropriate data for the ALU inputs, either from the raw register data or from forwarded data, based on the forwarding flags.

\subsubsection{ALU}
\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            read\_data\_1       & input  & 32 & Data for ALU input 1 \\
            read\_data\_2       & input  & 32 & Data for ALU input 2 \\
            imme                & input  & 32 & Immediate value \\
            ALU\_operation      & input  & 2  & ALU operation code \\
            ALU\_src\_flag      & input  & 1  & ALU source flag \\
            inst                & input  & 32 & Instruction data \\
            program\_counter    & input  & 32 & Program counter \\
            jal\_flag           & input  & 1  & JAL instruction flag \\
            jalr\_flag          & input  & 1  & JALR instruction flag \\
            lui\_flag           & input  & 1  & LUI instruction flag \\
            auipc\_flag         & input  & 1  & AUIPC instruction flag \\
            ALU\_result         & output & 32 & ALU result \\
            zero\_flag          & output & 1  & Zero result flag \\
            \bottomrule
        \end{tabular}
    }
\end{center}



\paragraph{Description}
The \texttt{ALU} module performs arithmetic and logical operations based on the control signals and input data. It produces the result and a zero flag indicating if the result is zero.

\subsubsection{Branch\_Target}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            jal\_flag                       & input  & 1  & JAL instruction flag \\
            jalr\_flag                      & input  & 1  & JALR instruction flag \\
            branch\_flag                    & input  & 1  & Branch flag \\
            zero\_flag                      & input  & 1  & Zero result flag \\
            read\_data\_1                   & input  & 32 & Data read from register 1 \\
            imme                            & input  & 32 & Immediate value \\
            program\_counter                & input  & 32 & Current program counter \\
            inst                            & input  & 32 & Instruction data \\
            program\_counter\_prediction    & input  & 32 & Predicted program counter \\
            wrong\_prediction\_flag         & output & 1  & Wrong prediction flag \\
            branch\_pc                      & output & 32 & Branch target address \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Branch\_Target} module calculates the target address for branch instructions and checks for branch prediction correctness.

\subsubsection{Memory\_Or\_IO}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            address\_absolute           & input  & 32 & Absolute address for memory or IO access \\
            inst                        & input  & 32 & Instruction data \\
            mem\_read\_flag             & input  & 1  & Memory read flag \\
            mem\_write\_flag            & input  & 1  & Memory write flag \\
            data\_memory\_read\_data    & input  & 32 & Data read from data memory \\
            io\_device\_read\_data      & input  & 32 & Data read from IO device \\
            read\_data                  & output & 32 & Data read from memory or IO \\
            data\_memory\_read\_flag    & output & 1  & Data memory read flag \\
            data\_memory\_write\_flag   & output & 1  & Data memory write flag \\
            io\_device\_read\_flag      & output & 1  & IO device read flag \\
            io\_device\_write\_flag     & output & 1  & IO device write flag \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Memory\_Or\_IO} module determines whether a memory or IO access should occur and manages the data transfer between the CPU and the respective memory or IO device.

\subsubsection{Data\_Memory}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk                 & input  & 1  & Clock signal \\
            address\_absolute   & input  & 32 & Absolute address for memory access \\
            write\_data         & input  & 32 & Data to be written to memory \\
            read\_flag          & input  & 1  & Memory read flag \\
            write\_flag         & input  & 1  & Memory write flag \\
            read\_data          & output & 32 & Data read from memory \\
            kick\_off\_flag     & input  & 1  & UART kick-off flag \\
            uart\_clk           & input  & 1  & UART clock signal \\
            upg\_wen            & input  & 1  & UART write enable \\
            upg\_adr            & input  & 14 & UART write address \\
            upg\_dat            & input  & 32 & UART write data \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Data\_Memory} module handles data storage and retrieval operations. It supports UART-based updates for loading new data into memory.

\subsubsection{IO\_Device\_Memory}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            clk                             & input  & 1  & Clock signal \\
            rst                             & input  & 1  & Reset signal \\
            address\_absolute               & input  & 32 & Absolute address for IO access \\
            write\_data                     & input  & 32 & Data to be written to IO device \\
            read\_flag                      & input  & 1  & IO read flag \\
            write\_flag                     & input  & 1  & IO write flag \\
            switch                          & input  & 24 & Switch inputs \\
            debounced\_button               & input  & 5  & Debounced button signals \\
            push\_button\_flag              & input  & 5  & Push button flag signals \\
            release\_button\_flag           & input  & 5  & Release button flag signals \\
            read\_data                      & output & 32 & Data read from IO device \\
            led                             & output & 24 & LED outputs \\
            seven\_seg\_tube                & output & 32 & Seven-segment tube data \\
            minus\_sign\_flag               & output & 8  & Minus sign flag for tube display \\
            dot\_flag                       & output & 8  & Dot flag for tube display \\
            show\_none\_flag                & output & 8  & Show none flag for tube display \\
            advanced\_mode\_flag            & output & 1  & Advanced mode flag \\
            adv\_seven\_seg\_tube\_left     & output & 32 & Advanced mode left tube data \\
            adv\_seven\_seg\_tube\_right    & output & 32 & Advanced mode right tube data \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{IO\_Device\_Memory} module manages the interaction with IO devices, including switches, buttons, LEDs, and seven-segment displays. It handles both reading from and writing to IO devices.

\subsubsection{Forwarding\_Unit}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            ALU\_result\_MEM                & input  & 32 & ALU result from MEM stage \\
            write\_reg\_idx\_MEM            & input  & 5  & Write register index from MEM stage \\
            write\_reg\_flag\_MEM           & input  & 1  & Register write flag from MEM stage \\
            mem\_to\_reg\_flag\_MEM         & input  & 1  & Memory to register flag from MEM stage \\
            ALU\_result\_WB                 & input  & 32 & ALU result from WB stage \\
            read\_data\_WB                  & input  & 32 & Data read from memory or IO in WB stage \\
            write\_reg\_idx\_WB             & input  & 5  & Write register index from WB stage \\
            write\_reg\_flag\_WB            & input  & 1  & Register write flag from WB stage \\
            mem\_to\_reg\_flag\_WB          & input  & 1  & Memory to register flag from WB stage \\
            read\_reg\_idx\_1\_EX           & input  & 5  & Read register index 1 from EX stage \\
            read\_reg\_idx\_2\_EX           & input  & 5  & Read register index 2 from EX stage \\
            read\_data\_1\_forwarding       & output & 32 & Forwarded data for register 1 \\
            read\_data\_2\_forwarding       & output & 32 & Forwarded data for register 2 \\
            read\_data\_1\_forwarding\_flag & output & 1  & Forwarding flag for register 1 \\
            read\_data\_2\_forwarding\_flag & output & 1  & Forwarding flag for register 2 \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Forwarding\_Unit} module resolves data hazards by forwarding the appropriate data from MEM and WB stages to the EX stage, ensuring that the ALU has the correct operands.

\subsubsection{Hazard\_Detection\_Unit}

\begin{center}
    \resizebox{\textwidth}{!}{
        \begin{tabular}{cccc}
            \toprule
            \textbf{Port Name} & \textbf{Port Type} & \textbf{Port Width} & \textbf{Description} \\
            \midrule
            write\_reg\_idx\_EX     & input  & 5 & Write register index from EX stage \\
            write\_reg\_flag\_EX    & input  & 1 & Register write flag from EX stage \\
            mem\_to\_reg\_flag\_EX  & input  & 1 & Memory to register flag from EX stage \\
            read\_reg\_idx\_1\_ID   & input  & 5 & Read register index 1 from ID stage \\
            read\_reg\_idx\_2\_ID   & input  & 5 & Read register index 2 from ID stage \\
            stall\_flag             & output & 1 & Stall signal \\
            \bottomrule
        \end{tabular}
    }
\end{center}

\paragraph{Description}
The \texttt{Hazard\_Detection\_Unit} module detects data hazards that require stalling the pipeline. It generates a stall signal when a hazard is detected, preventing incorrect data from being used.

\subsubsection{Pipeline Registers}

\paragraph{Description}
Pipeline registers are used to transmit the data between different stages. The ports of these pipeline registers are omitted here for simplicity. There are four pipeline registers in total. They are IF\_ID, ID\_EX, EX\_MEM, MEM\_WB. 

\section{Onboard instructions}

\subsection{Reset Operation}
\textbf{Reset Button: reset button is S6 on the board.} The reset button on the development board is used to perform a system reset. When the reset button is pressed, it sends a signal to the system to clear all registers and set the program counter (PC) to 0. 

\begin{itemize}
    \item \textbf{Note}: when the board is switched into UART communication mode, then the board is automatically reset, until the communication mode ends. 
\end{itemize}

\subsection{Input Operations}
The development board supports various input operations through switches and buttons:
\begin{itemize}
    \item \textbf{Switches}: The switches on the board can be used to provide various input signals to the system. These switches are connected to the \texttt{switch} input of the main module.
    \item \textbf{Buttons}: Only two buttons are effectively used for our CPU: S6 to reset the board, P2 to enter UART communication mode. 
\end{itemize}

\subsection{Output Operations}
The system outputs can be observed through the following regions on the development board:
\begin{itemize}
    \item \textbf{LEDs}: The LEDs on the board display the output signals from the system. Each LED corresponds to a specific bit in the output signal, allowing for easy monitoring of the system's status.
    \item \textbf{Seven-Segment Display}: The seven-segment displays are used to show numerical data and are controlled by the display driver module. The display driver handles various display flags and data inputs to control the tube selection and shape output.
\end{itemize}

\subsection{UART Communication}

Press button P2 to enter communication mode. The UART module handles the communication between the development board and an external device, allowing for data exchange and programming operations. 

\begin{itemize}
    \item \textbf{Note}: when the board is switched into UART communication mode, then the board is automatically reset, until the communication mode ends. 
\end{itemize}


\section{Self-Testing Instructions}

The tests include simulation and on-board testing, covering both unit and integration tests. The table below summarizes the test methods, test types, test case descriptions, and test results.

\begin{center}
    \begin{tabular}{|p{2.5cm}|p{2.5cm}|p{3cm}|p{1.5cm}|p{3.5cm}|}
        \hline
        \textbf{Test Method} & \textbf{Test Type} & \textbf{Test Case Description} & \textbf{Test Result} & \textbf{Conclusion} \\
        \hline
        Simulation & Unit Test & ALU operation \newline correctness & Pass & The ALU performs arithmetic \newline and logical operations correctly. \\
        \hline
        Simulation & Unit Test & Register file \newline read/write & Pass & Registers correctly store \newline and provide data as expected. \\
        \hline
        Simulation & Unit Test & Instruction fetch \newline and decode & Pass & Instructions are fetched \newline and decoded accurately. \\
        \hline
        On-board Testing & Integration Test & Complete CPU \newline functionality & Pass & The CPU executes a set \newline of predefined instructions \newline correctly on the hardware. \\
        \hline
        On-board Testing & Integration Test & UART communication & Pass & UART module successfully \newline transmits and receives data. \\
        \hline
        Simulation & Integration Test & Memory read/write \newline operations & Pass & Data memory performs \newline read and write operations \newline correctly. \\
        \hline
        Simulation & Integration Test & Pipeline register \newline transfer & Pass & Data and control signals \newline are correctly transferred \newline between pipeline stages. \\
        \hline
        On-board Testing & Unit Test & Button debounce \newline functionality & Pass & Buttons provide stable \newline signals without glitches. \\
        \hline
        Simulation & Integration Test & Branch prediction \newline accuracy & Pass & The branch prediction unit \newline correctly predicts and handles \newline branches. \\
        \hline
    \end{tabular}
\end{center}

\section{Bonus}

\subsection{Forwarding Unit}

The forwarding Unit module follows the very same idea from textbook ``Computer Organization and Design''. This module forwards data to ALU if a hazard happens. However, it cannot resolve load-use hazard, which is handled by Hazard Detection Unit.

The forwarding unit receive the register index to be written back in MEM and WB stage. If the index matches any of source register 1 or source register 2, it will forward the corresponding data to ALU. There are also two special case to handle. First, when the destination register is written in two consecutive instructions, the data in MEM stage is forwarded (since it is more recently updated). Second, if destination register is \texttt{x0}, we should not forward any data to ensure ALU get all 0 from register \texttt{x0}.

\begin{minted}[linenos, breaklines]{verilog}
module Forwarding_Unit(
    input [31:0] ALU_result_MEM,
    input [4:0] write_reg_idx_MEM,
    input write_reg_flag_MEM,
    input mem_to_reg_flag_MEM,
    input [31:0] ALU_result_WB,
    input [31:0] read_data_WB,
    input [4:0] write_reg_idx_WB,
    input write_reg_flag_WB,
    input mem_to_reg_flag_WB,
    input [4:0] read_reg_idx_1_EX,
    input [4:0] read_reg_idx_2_EX,

    output reg [31:0] read_data_1_forwarding,
    output reg [31:0] read_data_2_forwarding,
    output read_data_1_forwarding_flag,
    output read_data_2_forwarding_flag
);

wire MEM_hazard_1_flag;
wire MEM_hazard_2_flag;
wire WB_hazard_1_flag;
wire WB_hazard_2_flag;

assign MEM_hazard_1_flag = (write_reg_flag_MEM && (write_reg_idx_MEM == read_reg_idx_1_EX) && (read_reg_idx_1_EX != 0) && !mem_to_reg_flag_MEM);
assign MEM_hazard_2_flag = (write_reg_flag_MEM && (write_reg_idx_MEM == read_reg_idx_2_EX) && (read_reg_idx_2_EX != 0) && !mem_to_reg_flag_MEM);
assign WB_hazard_1_flag = (write_reg_flag_WB && (write_reg_idx_WB == read_reg_idx_1_EX) && (read_reg_idx_1_EX != 0));
assign WB_hazard_2_flag = (write_reg_flag_WB && (write_reg_idx_WB == read_reg_idx_2_EX) && (read_reg_idx_2_EX != 0));

assign read_data_1_forwarding_flag = MEM_hazard_1_flag || WB_hazard_1_flag;
assign read_data_2_forwarding_flag = MEM_hazard_2_flag || WB_hazard_2_flag;

always @* begin
    if (read_data_1_forwarding_flag)
        if (MEM_hazard_1_flag)
            read_data_1_forwarding = ALU_result_MEM;
        else
            if (mem_to_reg_flag_WB)
                read_data_1_forwarding = read_data_WB;
            else
                read_data_1_forwarding = ALU_result_WB;
    else
        read_data_1_forwarding = 32'b0;

    if (read_data_2_forwarding_flag)
        if (MEM_hazard_2_flag)
            read_data_2_forwarding = ALU_result_MEM;
        else
            if (mem_to_reg_flag_WB)
                read_data_2_forwarding = read_data_WB;
            else
                read_data_2_forwarding = ALU_result_WB;
    else
        read_data_2_forwarding = 32'b0;
end

endmodule
\end{minted}

\subsection{Hazard Detection Unit}

This module detects load-use hazard and send corresponding signals to other modules. It detect load-use hazard early in ID and EX stage. First, it checks if the ID instruction (instruction in ID stage) tries to read from the same register being written in EX instruction. If so, it checks if the EX instruction is a load instruction. If this is also true, then we find a load-use hazard.

To resolve this, a stall command will be send to PC and IF/ID pipeline register, making them maintain their current value for one clock cycle (this will keep the instruction in IF and ID stage unchanged). At the same time, the ID/EX pipeline register will also receive a command that makes it output \texttt{nop}. This effectively let the instructions in the first two stage stay still, and the instructions in the other stages keep moving, and insert an \texttt{nop} into the gap.

Then, in the next cycle, the data is fetched from memory and moves into WB stage. Then the forwarding unit can handle the hazard by forwarding WB data to ALU.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{figure/Hazard Detection.png}
\end{figure}

\begin{minted}[linenos, breaklines]{verilog}
module Hazard_Detection_Unit(
    input [4:0] write_reg_idx_EX,
    input write_reg_flag_EX,
    input mem_to_reg_flag_EX,
    input [4:0] read_reg_idx_1_ID,
    input [4:0] read_reg_idx_2_ID,

    output stall_flag
);

assign stall_flag = (write_reg_flag_EX && mem_to_reg_flag_EX && write_reg_idx_EX != 0 && (write_reg_idx_EX == read_reg_idx_1_ID || write_reg_idx_EX == read_reg_idx_2_ID));
endmodule

\end{minted}

\subsection{Branch Prediction}

For branch prediction, we implemented a module \texttt{Program\_Counter\_Prediction}. The module's core component is a 4 element 64 bit array, that serves as a LRU cache. For each entry of the cache, the first 32 bits store the program counter value of a branch instruction, and the last 32 bits store the program counter value of target instruction (where branch instruction goes to). Every clock cycle, the module checks if current program counter value matches any entry. If so, it will directly set the next value of program counter to the last 32 bits of that entry. Otherwise, it simply add 4 to current value.

The update of the cache is done when branching takes place. The \texttt{Branch\_Target} module will send a 64 bit entry to \texttt{Program\_Counter\_Prediction} and a LRU replacement will be performed.

\newpage
\begin{minted}[linenos, breaklines]{verilog}
module Program_Counter_Prediction(
    input             clk,
    input             rst,
    input      [31:0] branch_from_pc,               // where the branch instruction is
    input      [31:0] branch_to_pc,                 // where the branch instruction will go
    input      [31:0] program_counter,
    input             branch_flag,
    
    output reg [31:0] program_counter_prediction,
    output reg [31:0] prev_pcp
);

// Each LRU_cache is divided into 2 parts
// The first half stores the branch_from_pc (where the branch instruction is)
// The second half stores the branch_to_pc (where the branch instruction will go)
// If the branch_from_pc is in the LRU_cache, the most recent branch_to_pc is the prediction
// If the branch_from_pc is not in the LRU_cache, we predict branch will not be taken

reg [63:0] LRU_cache [0:3];
reg current_pc_in_cache_flag;
reg [1:0] current_pc_in_cache_idx;
reg branch_from_pc_in_cache_flag;
reg [1:0] branch_from_pc_in_cache_idx;
reg [2:0] LRU_capacity;

always @* begin
    if (LRU_cache[0][31:0] == program_counter) begin
        current_pc_in_cache_flag = 1'b1;
        current_pc_in_cache_idx = 2'b00;
    end
    else if (LRU_cache[1][31:0] == program_counter) begin
        current_pc_in_cache_flag = 1'b1;
        current_pc_in_cache_idx = 2'b01;
    end
    else if (LRU_cache[2][31:0] == program_counter) begin
        current_pc_in_cache_flag = 1'b1;
        current_pc_in_cache_idx = 2'b10;
    end
    else if (LRU_cache[3][31:0] == program_counter) begin
        current_pc_in_cache_flag = 1'b1;
        current_pc_in_cache_idx = 2'b11;
    end
    else begin
        current_pc_in_cache_flag = 1'b0;
        current_pc_in_cache_idx = 2'b00;
    end

    if (LRU_cache[0][31:0] == branch_from_pc) begin
        branch_from_pc_in_cache_flag = 1'b1;
        branch_from_pc_in_cache_idx = 2'b00;
    end
    else if (LRU_cache[1][31:0] == branch_from_pc) begin
        branch_from_pc_in_cache_flag = 1'b1;
        branch_from_pc_in_cache_idx = 2'b01;
    end
    else if (LRU_cache[2][31:0] == branch_from_pc) begin
        branch_from_pc_in_cache_flag = 1'b1;
        branch_from_pc_in_cache_idx = 2'b10;
    end
    else if (LRU_cache[3][31:0] == branch_from_pc) begin
        branch_from_pc_in_cache_flag = 1'b1;
        branch_from_pc_in_cache_idx = 2'b11;
    end
    else begin
        branch_from_pc_in_cache_flag = 1'b0;
        branch_from_pc_in_cache_idx = 2'b00;
    end

    if (current_pc_in_cache_flag && current_pc_in_cache_idx < LRU_capacity) begin
        program_counter_prediction = LRU_cache[current_pc_in_cache_idx][63:32];
    end
    else begin
        program_counter_prediction = program_counter + 4;
    end
end

always @(negedge clk) begin
    if (rst) begin
        prev_pcp <= 32'h00000000;
    end
    else begin
        prev_pcp <= program_counter_prediction;
    end

    if (rst) begin
        LRU_cache[0] <= 64'h0000000000000000;
        LRU_cache[1] <= 64'h0000000000000000;
        LRU_cache[2] <= 64'h0000000000000000;
        LRU_cache[3] <= 64'h0000000000000000;
        LRU_capacity <= 3'b000;
    end
    else if (branch_flag) begin
        if (branch_from_pc_in_cache_flag) begin
            case (branch_from_pc_in_cache_idx)
                2'b00: begin
                    LRU_cache[0] <= {branch_to_pc, branch_from_pc};
                    LRU_cache[1] <= LRU_cache[1];
                    LRU_cache[2] <= LRU_cache[2];
                    LRU_cache[3] <= LRU_cache[3];
                end
                2'b01: begin
                    LRU_cache[0] <= {branch_to_pc, branch_from_pc};
                    LRU_cache[1] <= LRU_cache[0];
                    LRU_cache[2] <= LRU_cache[2];
                    LRU_cache[3] <= LRU_cache[3];
                end
                2'b10: begin
                    LRU_cache[0] <= {branch_to_pc, branch_from_pc};
                    LRU_cache[1] <= LRU_cache[0];
                    LRU_cache[2] <= LRU_cache[1];
                    LRU_cache[3] <= LRU_cache[3];
                end
                2'b11: begin
                    LRU_cache[0] <= {branch_to_pc, branch_from_pc};
                    LRU_cache[1] <= LRU_cache[0];
                    LRU_cache[2] <= LRU_cache[1];
                    LRU_cache[3] <= LRU_cache[2];
                end
            endcase
            LRU_capacity <= LRU_capacity;
        end
        else begin
            LRU_cache[0] <= {branch_to_pc, branch_from_pc};
            LRU_cache[1] <= LRU_cache[0];
            LRU_cache[2] <= LRU_cache[1];
            LRU_cache[3] <= LRU_cache[2];
            if (LRU_capacity == 3'b100) begin
                LRU_capacity <= 3'b100;
            end
            else begin
                LRU_capacity <= LRU_capacity + 1;
            end
        end
    end
end

endmodule
\end{minted}

\subsection{\texttt{lui} and \texttt{auipc}}

The \texttt{lui} and \texttt{auipc} would require addition information, which is the value of program counter. We detect these two instructions in \texttt{ALU} module. If any is found, the ALU\_result will be the corresponding value of U-type command, instead of normal arithmatic operation. This also works for \texttt{jal} and \texttt{jalr} instructions.

Below is part of code from \texttt{ALU} module.

\begin{minted}[linenos, breaklines]{verilog}
always @* begin
    if (jal_flag || jalr_flag) begin
        ALU_result = program_counter + 4;
    end 
    else if (lui_flag) begin
        ALU_result = imme;
    end 
    else if (auipc_flag) begin
        ALU_result = program_counter + imme;
    end 
    else
        case(ALU_control)
            4'b0000:
            begin
                ALU_result = operand_1 + operand_2;
            end
            4'b0001:
            begin
                ALU_result = operand_1 - operand_2;
            end
            4'b0010:
            begin
                ALU_result = operand_1 ^ operand_2;
            end
            4'b0011:
            begin
                ALU_result = operand_1 | operand_2;
            end
            4'b0100:
            begin
                ALU_result = operand_1 & operand_2;
            end
            4'b0101:
            begin
                ALU_result = operand_1 << operand_2[4:0];
            end
            4'b0110:
            begin
                ALU_result = operand_1 >> operand_2[4:0];
            end
            4'b0111:
            begin
                ALU_result = operand_1 >>> operand_2[4:0];
            end
            4'b1000:
            begin
                ALU_result = ($signed(operand_1) < $signed(operand_2)) ? 32'b1 : 32'b0;
            end
            4'b1001:
            begin
                ALU_result = (operand_1 < operand_2) ? 32'b1 : 32'b0;
            end
            default:
            begin
                ALU_result = 32'b0;
            end
        endcase
end
\end{minted}

\section{Issues and Summary}

\subsection{Issues Encountered}

During the development process, several issues were encountered that required careful analysis and resolution:

\begin{itemize}
    
    \item \textbf{UART Communication:} When implementing UART communication mode, we found that unit test works properly, but the integrated test failed. It is because the MSB of UART address is used to distinguish data for instruction memory and for data memory, not an actual data address.
    
    \item \textbf{Memory Management:} There should be an address shifting when implementing memory IP core. Because memory IP core always start at address \texttt{0}, but in the memory layout of RARS, the address of memory usually isn't (in our case data memory starts at \texttt{0x2000}). This is because RARS is designed for Von Neumann architecture, where the data memory and instruction memory is stored in the same hardware (address before \texttt{0x2000} is reserved for instruction memory). So we implemented shifting when accessing memories (data memory address for IP core = raw data memory address generated by RARS - \texttt{0x2000}) to better utilized memory. When dumping the memories contents, we should properly configure the memory layout to obtain the correct result.

    \item \textbf{Latch:} When writing case statement in Verilog, we should consider all the possible cases, since unidentified cases may lead to latches.

\end{itemize}

\subsection{Thoughts}

Throughout the development process, several key considerations were highlighted:

\begin{itemize}
    % \item \textbf{Modular Design:} Emphasizing a modular design approach proved beneficial. Each module was designed, tested, and verified independently before integration, simplifying debugging and enhancing maintainability.
    
    % \item \textbf{Testing and Verification:} Rigorous testing at both unit and integration levels was essential. Simulations provided an effective way to identify and resolve issues before on-board testing, saving time and resources.
    
    \item \textbf{Documentation:} We pay careful attention to the documentations and comments in the project. Each module is documented in detail, and some necessary notes to understand the code logic are also added. Thanks to this convention, each team member's code can be easily understood by others, which greatly boost the efficiency of our project.
    
    \item \textbf{Team Collaboration:} We use version control tool Git to facilitate out CPU development. Some conventions are followed, for example, we have several branches like dev, test, debug etc.

    \item \textbf{Incremental Development:} Our Pipeline CPU scheme is not devised from scratch. We adopted an incremental development approach during the project. We implemented a single-cycle CPU at first. We tackled some issues with it,  ensuring that these modules were robust when later being reused in the pipeline schematic. More importantly, we realized the biggest drawback of single-cycle CPU - we don't have enough clock edges to trigger different events, but these events are supposed to be done in a defined sequence with more than 2 steps (hence only two edges in a single cycle is hardly enough). But this problem is perfectly handled by pipeline CPU.

    \item \textbf{Code Convention:} It's important to have a code convention, especially for pipeline development. This is because each stage needs to maintain its own flag and variables. For example each stage manages its current instruction, then there needs to be different naming for instruction variables in different stages.

\end{itemize}

\subsection{Summary}

In summary, the development process was marked by a series of challenges that were successfully overcome through careful planning, rigorous testing, and effective teamwork. We really enjoy this project, and appreciate our teacher.

% \begin{itemize}
%     \item \textbf{Successful Module Integration:} All modules were integrated seamlessly, resulting in a fully functional system that met the design specifications.
    
%     \item \textbf{Enhanced Performance:} Optimizations in clock synchronization, debouncing, UART communication, and branch prediction significantly improved system performance.
    
%     \item \textbf{Robust Testing Framework:} The development of a comprehensive testing framework ensured the reliability and stability of the system, with all test cases passing successfully.
    
%     \item \textbf{Valuable Learning Experience:} The project provided valuable insights into complex system design and highlighted the importance of thorough testing, documentation, and collaboration.
% \end{itemize}

% Overall, the project was a success, delivering a robust and efficient system while providing significant learning and growth opportunities for the development team.

\end{document}
